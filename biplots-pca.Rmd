---
title: Work in progress
output:
    bookdown::pdf_document2
classoption: fleqn
---

# Pre-proccesing

```{r loadingdata, echo=FALSE}
knitr::opts_chunk$set(echo = FALSE, dpi = 300)
set.seed(842744)
library(dplyr, warn.conflicts = FALSE)

link <- "https://raw.githubusercontent.com/abarahonar/biplots-pca/master/owid-covid-data.csv" # nolint
data_original <- read.csv(url(link), header = TRUE)
```

The data used for this work comes from [Our World In Data's repositories](https://github.com/owid/covid-19-data/tree/master/public/data). The last entry on the data set corresponds to 10/08/2021.

## Cleaning

```{r deletingowidentries}
# Remove aggregations of data
# Those are denoted as an iso_code starting with OWID
ptn <- "^[^O][^W][^I][^D]*" # Will match anything that doesn't start with OWID
ndx <- grep(ptn, data_original$iso_code, perl = TRUE)
data <- data_original[ndx, ]
# To test it: unique(data.clean[c("iso_code")])
```

The original data set contains `r count(data_original)` entries with `r ncol(data_original)` variables. However, not all the data is needed. There are several entries that are not useful as they correspond to aggregations of data in terms of geolocalization. These entries marked as OWID consists of `r ceiling((1 - count(data)/count(data_original))*100)`% of the original data set. 

The variables in the data set can be used to represent two types of information: the evolution of the pandemic as a time series and metrics regarding the situation of the countries as a whole. The former correspond to dynamic data while the latter is static data.

### Countries data set
The variables used to represent the countries are:

```{r definitionofcountryvariables}
library(pander, warn.conflicts = FALSE)

country_variables <- c(
  "population",
  "population_density",
  "median_age",
  "gdp_per_capita",
  "cardiovasc_death_rate",
  "diabetes_prevalence",
  "hospital_beds_per_thousand",
  "life_expectancy",
  "human_development_index",
  "female_smokers",
  "male_smokers",
  "extreme_poverty"
)

countries <- data[, which(names(data) %in% c("iso_code", country_variables))]
countries <- distinct(countries)
countries$extreme_poverty[is.na(countries$extreme_poverty)] <- 0
pander(country_variables)
```

The corresponding data set regarding the countries contains `r count(countries)` entries. However, not every country started reporting at the same time, in some situations there are noticeable differences in the starting reporting dates. A sample of the starting reporting dates can be seen in the Table \@ref(tab:reportingdates).

```{r reportingdates}
library(knitr, warn.conflicts = FALSE)

reporting_dates <- data[!duplicated(data$iso_code), ][c("iso_code", "date")]
rownames(reporting_dates) <- NULL

head_dates <- head(reporting_dates, n = 5)
tail_dates <- tail(reporting_dates, n = 5)

reporting_dates_t <- rbind(head_dates, tail_dates)
colnames(reporting_dates_t) <- c("ISO code", "Starting reporting date")

kable(reporting_dates_t, caption = "First and last 5 countries and their starting reporting dates. Alphabeticaly sorted. It can be seen in the fifth entry that the reporting date starts 1 year later in comparison to the majority of countries.") # nolint

fast_countries <- reporting_dates[reporting_dates$date < "2020-05-01", ]
countries <- countries[countries$iso_code %in% fast_countries$iso_code, ]
```

The date 05/01/2020 was selected as the threshold with which countries are removed from the data set. If they started reporting at a latter date, they are not considered. The remaining countries consists of `r count(countries)` entries.

```{r deletingnas}
countries <- na.omit(countries)
countries_with_names <- countries[, -1]
rownames(countries_with_names) <- countries[, 1]
countries <- countries_with_names
```

The next trimming consists of eliminating entries with one or more NA (***not assigned***) values. After this, the data set consists of `r count(countries)` entries. To see the behaviour of the data set, refer to the Figure \@ref(fig:lotboxplots).

```{r lotboxplots, fig.cap = "Boxplots of the different variables"}
library(ggplot2, warn.conflicts = FALSE)
library(reshape2, warn.conflicts = FALSE)

# The scales are way too big, we should normalize
countries_scaled <- scale(subset(countries, select = -c(population)))
ggplot(melt(countries_scaled), aes(Var2, value)) +
  geom_boxplot() +
  labs(x = "Variable's name", y = "Standardized values") +
  coord_flip()
```

### Time series data set

Regarding the time series, the entries related to countries that started to report significantly later than the others, and the measures that are before the aforementioned threshhold date are deleted. On top of that, variables that have a high percentage of NA values are not taken into consideration. A rundown of these variables can be seen in Table \@ref(tab:percentagesTable). It is worth mentioning that not all the variables shown in the aforementioned table are deleted, some of them are too importante to be discarded (like `total_test_per_thousand`)

```{r}
columns_to_delete <- c(
  "continent",
  "location",
  "excess_mortality_cumulative_absolute",
  "excess_mortality_cumulative",
  "excess_mortality",
  "excess_mortality_cumulative_per_million",
  "handwashing_facilities",
  "icu_patients",
  "icu_patients_per_million",
  "hosp_patients",
  "hosp_patients_per_million",
  "weekly_icu_admissions",
  "weekly_icu_admissions_per_million",
  "weekly_hosp_admissions",
  "weekly_hosp_admissions_per_million",
  "new_cases_smoothed",
  "new_deaths_smoothed",
  "new_cases_smoothed_per_million",
  "new_deaths_smoothed_per_million",
  "new_tests_smoothed",
  "new_tests_smoothed_per_thousand",
  "new_vaccinations_smoothed",
  "new_vaccinations_smoothed_per_million",
  "positive_rate",
  "total_cases",
  "new_cases",
  "total_deaths",
  "new_deaths",
  "new_tests",
  "total_tests",
  "total_vaccinations",
  "people_vaccinated",
  "people_fully_vaccinated",
  "total_boosters",
  "new_vaccinations",
  "aged_65_older",
  "tests_units",
  "aged_70_older",
  "people_vaccinated_per_hundred",
  "people_fully_vaccinated_per_hundred"
)

unnecesary_variables <- c(
  columns_to_delete,
  country_variables
)

time_series <- data[, -which(names(data) %in% unnecesary_variables)]
time_series <- time_series[time_series$iso_code %in% rownames(countries), ]
time_series <- time_series[time_series$date >= "2020-05-01", ]
```

```{r percentagesTable}
percentages <- sapply(data,
                      function(x) ceiling(sum(is.na(x)) / count(data) * 100))
percentages <- as.data.frame(percentages)
percentages <- t(percentages)
percentages <- percentages[percentages > 60, ]
percentages <- as.data.frame(percentages)
percentages <- cbind(Row.Names = rownames(percentages), percentages)
rownames(percentages) <- NULL
colnames(percentages) <- c("variable", "percentage")
percentages$variable <- substr(percentages$variable,
                              1,
                              nchar(percentages$variable) - 2)
kable(percentages, caption="Variables with a percentage of NA values over 60\\%") # nolint
```

Another processing done to the time series corresponds to deleting relative variables to the day. This is done because its easier to interpret missing values in acumulative variables. The way it is interpreted is through the assumption that it takes the last known value. In the cases when there is no previous information, it is assumed to be 0.

```{r}
# Actually the next elimination can be only applied to total cases because they are the sum of every day cases. If we set previous values for an NA in columns like new_cases then we artificially increase total cases(?) because to determine total we sum up new once # nolint

# El unico problema de solamente tener los totales es que se pierden las correlaciones (ya que las variables siempre son crecientes) # nolint
totals <- subset(time_series, select = -c(
  new_tests_per_thousand,
  new_deaths_per_million,
  tests_per_case,
  new_cases_per_million
))

totals_modifies <- totals[0, ]

for (i in rownames(countries)) { # for each country
  country_subset <- totals[totals$iso_code == i, ]
  country_subset_mod <- country_subset
  # for each column name
  for (j in colnames(subset(country_subset, select = -c(date, iso_code)))) {
    col.values <- country_subset[[j]] #select one column
    for (k in seq_along(col.values)) {
      if (is.na(col.values[[k]])) { # if value = NA
        if (k == 1) { # if first element -> set = 0
          country_subset_mod[[j]][[k]] <- 0.0
        } else { # else set the last known one
          country_subset_mod[[j]][[k]] <- country_subset_mod[[j]][[k - 1]]
        }
      }
    }
  }
  totals_modifies <- rbind(totals_modifies, country_subset_mod)
}

time_series <- totals_modifies
```

#### Agreggation of temporal data

```{r}
aggregate_data <- function(countries, time_series, jump) {
  to_return <- time_series[0, ]
  for (i in rownames(countries)) {
    country_subset <- time_series[time_series$iso_code == i, ] # nolint
    j <- jump
    while (j <= nrow(country_subset)) {
      temp <- time_series[0, ]
      temp[1, ] <- NA
      temp[[1]][[1]] <- country_subset[[1]][[1]]
      temp[[2]][[1]] <- country_subset[[2]][[j]]
      for (k in colnames(subset(country_subset, select = -c(date, iso_code)))) {
        temp[[k]][[1]] <- country_subset[[k]][[j]]
      }
      to_return <- rbind(to_return, temp)
      j <- j + jump
    }
  }
  return(to_return)
}

time_series_weekly <- aggregate_data(countries, time_series, 7)
time_series_biweekly <- aggregate_data(countries, time_series, 14)
time_series_monthly <- aggregate_data(countries, time_series, 31)
```

```{r}
new_t <- time_series_monthly[0, ]
for (i in rownames(countries)) {
  subset_t <- time_series_monthly[time_series_monthly$iso == i,]
  mod <- subset_t
  for (j in colnames(subset(subset_t, select = -c(date, iso_code, reproduction_rate, stringency_index)))) {
    col_values <- subset_t[[j]]
    number_of_entries_for_country = max(seq_along(col_values))
    while (number_of_entries_for_country > 1) {
      mod[[j]][[number_of_entries_for_country]] <- mod[[j]][[number_of_entries_for_country]] - mod[[j]][[number_of_entries_for_country - 1]]
      number_of_entries_for_country <- number_of_entries_for_country - 1
    }
  }
  new_t <- rbind(new_t, mod)
}


time_series_monthly_only_new_values <- new_t %>% 
  rename(
    new_cases = total_cases_per_million,
    new_deaths = total_deaths_per_million,
    new_tests = total_tests_per_thousand,
    new_vaccinations = total_vaccinations_per_hundred,
    new_boosters = total_boosters_per_hundred
    )
time_series_monthly_only_new_values
```

Aggregation of data is done by temporal terms rather than geographical terms. This means that the time series is available with a daily, weekly, biweekly and monthly evolution, with `r nrow(time_series)`, `r nrow(time_series_weekly)`, `r nrow(time_series_biweekly)`, `r nrow(time_series_monthly)` entries respectively.

#### Plots of some variables in countries
```{r}
# interesting_countires <- c(
#   "RUS",
#   "CHL",
#   "CHN",
#   "USA",
#   "DEU",
#   "FRA",
#   "BRA",
#   "TUR",
#   "ITA",
#   "KOR"
#   ) #countries to plot
# 
# # Plot all totals
# subset <- time_series[time_series$iso_code %in% interesting_countires, ]
# p <- ggplot(data = subset,
#             aes(x = date, y = total_cases_per_million,
#             group = iso_code)) +
#   geom_line(aes(color = iso_code)) +
#   theme(axis.text.x = element_blank())
# print(p)
# # }
# subset <- time_series[time_series$iso_code %in% interesting_countires, ]
# p <- ggplot(data = subset,
#             aes(x = date, y = total_deaths_per_million, group = iso_code)) +
#   geom_line(aes(color = iso_code)) +
#   theme(axis.text.x = element_blank())
# print(p)
# 
# subset <- time_series[time_series$iso_code %in% interesting_countires, ]
# p <- ggplot(data = subset,
#             aes(x = date, y = reproduction_rate, group = iso_code)) +
#   geom_line(aes(color = iso_code)) +
#   theme(axis.text.x = element_blank())
# print(p)
# 
# subset <- time_series[time_series$iso_code %in% interesting_countires, ]
# p <- ggplot(data = subset,
#             aes(x = date, y = total_tests_per_thousand, group = iso_code)) +
#   geom_line(aes(color = iso_code)) +
#   theme(axis.text.x = element_blank())
# print(p)
# 
# subset <- time_series[time_series$iso_code %in% interesting_countires, ]
# p <- ggplot(data = subset,
#             aes(x = date,
#                 y = total_vaccinations_per_hundred,
#                 group = iso_code)) +
#   geom_line(aes(color = iso_code)) +
#   theme(axis.text.x = element_blank())
# print(p)
# 
# subset <- time_series[time_series$iso_code %in% interesting_countires, ]
# p <- ggplot(data = subset,
#             aes(x = date,
#                 y = people_vaccinated_per_hundred,
#                 group = iso_code)) +
#   geom_line(aes(color = iso_code)) +
#   theme(axis.text.x = element_blank())
# print(p)
# 
# subset <- time_series[time_series$iso_code %in% interesting_countires, ]
# p <- ggplot(data = subset,
#             aes(x = date,
#                 y = people_fully_vaccinated_per_hundred,
#                 group = iso_code)) +
#   geom_line(aes(color = iso_code)) +
#   theme(axis.text.x = element_blank())
# print(p)
# 
# subset <- time_series[time_series$iso_code %in% interesting_countires, ]
# p <- ggplot(data = subset,
#             aes(x = date, y = total_boosters_per_hundred, group = iso_code)) +
#   geom_line(aes(color = iso_code)) +
#   theme(axis.text.x = element_blank())
# print(p)
# 
# subset <- time_series[time_series$iso_code %in% interesting_countires, ]
# p <- ggplot(data = subset,
#             aes(x = date, y = stringency_index, group = iso_code)) +
#   geom_line(aes(color = iso_code)) +
#   theme(axis.text.x = element_blank())
# print(p)
# 
# subset <- time_series[time_series$iso_code %in% interesting_countires, ]
# p <- ggplot(data = subset,
#             aes(x = date, y = total_cases_per_million, group = iso_code)) +
#   geom_line(aes(color = iso_code)) +
#   theme(axis.text.x = element_blank())
# print(p)
```

## Biplots
```{r pca}
time_series_monthly_pca <- data.frame(time_series_monthly)
time_series_monthly_pca$iso_code <-  NULL
time_series_monthly_pca$date <- NULL
pca <- prcomp(time_series_monthly_pca, scale = TRUE)

layout(matrix(1:2, ncol = 2))
screeplot(pca)
screeplot(pca, type = "lines")

time_series_monthly_only_new_values_pca <- data.frame(time_series_monthly_only_new_values)
time_series_monthly_only_new_values_pca$iso_code <-  NULL
time_series_monthly_only_new_values_pca$date <- NULL
pca_new <- prcomp(time_series_monthly_only_new_values_pca, scale = TRUE)

layout(matrix(1:2, ncol = 2))
screeplot(pca_new)
screeplot(pca_new, type = "lines")
```

```{r biplot}
get_pca_aces <- function(pca, y_dimention, left_limit, right_limit, bottom_limit, up_limmit) {

s <- summary(pca)
l_x <- pca$rotation[, 1] * 10
l_y <- pca$rotation[, y_dimention] * 10
lo <- which(l_y < 0)
hi <- which(l_y > 0)
l_pos <- l_y
l_pos <- replace(l_pos, lo, "1")
l_pos <- replace(l_pos, hi, "3")

plot(
  pca$x[, 1],
  pca$x[, y_dimention],
  xlab = paste("PCA 1 (", round(s$importance[2] * 100, 1), "%)", sep = ""),
  ylab = paste("PCA ", y_dimention, " (", round(s$importance[2+3*(y_dimention-1)] * 100, 1), "%)", sep = ""),
  las = 1,
  col = "white",
  ylim = c(bottom_limit, up_limmit),
  xlim = c(left_limit, right_limit)
  )
abline(v = 0, lty = 2, col = "grey50")
abline(h = 0, lty = 2, col = "grey50")
arrows(
  x0 = 0,
  x1 = l_x,
  y0 = 0,
  y1 = l_y,
  col =
  "red",
  length = 0.15,
  lwd = 1.5
  )
text(
  l_x,
  l_y,
  labels = row.names(pca$rotation),
  col = "red",
  pos = l_pos,
  lwd = 1.5,
  cex = 0.7
  )
}

get_pca_aces(pca, 2, -1, 6.5, -10, 9)
get_pca_aces(pca, 3, -1, 6.5, -10, 9)
get_pca_aces(pca, 4, -1, 6.5, -10, 9)


get_pca_aces(pca_new, 2, -1, 6.5, -10, 9)
get_pca_aces(pca_new, 3, -1, 6.5, -10, 9)
get_pca_aces(pca_new, 4, -1, 6.5, -10, 9)


```

The variables that are superposed correspond to `total_vaccionations_per_hundred`, `people_vaccinated_per_hundred` and `people_fully_vaccinated_per_hundred`.

Due to the angles of the rotations, we speculate that the 1rst component in the PCA is related to data regarding death, cases, test and vaccinations.

From the PCA of the accumulative values we can conclude that two first components are not sufficient to represent the data set, first of all, because it only contains 54% of the information. More than that, observation of the correlation between PCA components shows that simply taking the first two components is not fully representative. For example, within the second component we can observe direct proportionality between stringency index and reproduction rate, whereas the forth component shows inverse proportionality of the two values.

As for the PCA of the non accumulated data, there is only 44,9% of information if the first two variables.
Therefore, we decided to reduce the number of variables by deleting boosters information. This decision can be justified by the fact that only few countries applied booster vaccination campaign and the first boosters data appeared only in May  and therefore 99% of values are non assigned.

```{r countriesbiplot}
l_x <- pca$rotation[, 1] * 5
l_y <- pca$rotation[, 2] * 5

plot(
  pca$x[, 1],
  pca$x[, 2],
  xlab = paste("PCA 1 (", round(s$importance[2] * 100, 1), "%)", sep = ""),
  ylab = paste("PCA 2 (", round(s$importance[5] * 100, 1), "%)", sep = ""),
  las = 1,
  cex = 0.5,
  col = "black",
  )
abline(v = 0, lty = 2, col = "grey50")
abline(h = 0, lty = 2, col = "grey50")
arrows(
  x0 = 0,
  x1 = l_x,
  y0 = 0,
  y1 = l_y,
  col = "#ff7f7f",
  length = 0.15,
  lwd = 1.5,
  cex = 0.5
  )
```
```{r}
 # PCA without boosters
pca_no_boosters <- prcomp(subset(time_series_monthly_pca, select = -c(total_boosters_per_hundred)), scale = TRUE)
pca_new_no_boosters <- prcomp(subset(time_series_monthly_only_new_values_pca, select = -c(new_boosters)), scale = TRUE)

get_pca_aces(pca_no_boosters, 2, -1, 6.5, -10, 9)
get_pca_aces(pca_no_boosters, 3, -1, 6.5, -10, 9)
get_pca_aces(pca_no_boosters, 4, -1, 6.5, -10, 9)


get_pca_aces(pca_new_no_boosters, 2, -6.5, 1, -10, 9)
get_pca_aces(pca_new_no_boosters, 3, -6.5, 1, -10, 9)
get_pca_aces(pca_new_no_boosters, 4, -6.5, 1, -10, 9)


```

```{r interestingcountries}
interesting_countries <- c("RUS", "CHL", "CHN", "USA", "DEU", "FRA", "BRA", "TUR", "ITA", "KOR")

get_lines <- function() {
  months_data <- unique(time_series_monthly$date)
  indexes_1 <- which(time_series_monthly$iso_code %in% interesting_countries)
  names <- NULL
  x_axis <- NULL
  y_axis <- NULL
  for (month in months_data) {
    indexes_2 <- which(time_series_monthly$date == month)
    indexes <- intersect(indexes_1, indexes_2)
    pca_interesting <- pca
    pca_interesting$x <- pca$x[indexes, ]
    x_axis <- c(x_axis, pca_interesting$x[, 1])
    y_axis <- c(y_axis, pca_interesting$x[, 2])
    names <- c(names, time_series_monthly[indexes, ]$iso_code)
  }
  df <- do.call(data.frame, list(x_axis, y_axis, names))
  colnames(df) <- c("x", "y", "iso_code")
  return(df)
}

cols <- rainbow(length(interesting_countries))
l_x <- pca$rotation[, 1] * 5
l_y <- pca$rotation[, 2] * 5
df <- get_lines()

ggplot() +
  geom_line(data = df, aes(x = x, y = y, colour = iso_code)) +
  labs(colour = "Country", x = "Deaths, vaccinations and testing", y = "Reproduction and stringency", title = "Evolution of coronavirus")

```

## Hierarchical clustering


For clustering the countries, we're not taking into consideration absolute values like population. Instead, to compare the countries we take into consideration relative parameters like density of population. Also, we excluded two countries from our data frame: Bangladesh and Malta. Both of them have way too high population density which would group them in a separate class.
After clustering the data and analyzing the dendogram we decided to divide our data set into 5 classes.

```{r dendogram, fig.cap="Hierarchical clustering"}
# Remove outliers
outliers_list <- c("MUS", "MLT", "BGD", "SGP")
countries_scaled_no_outliers <- countries_scaled[!(row.names(countries_scaled) %in% outliers_list), ]
# No outliers + no absolute population
countries_no_outliers <-subset(countries[!(row.names(countries) %in% outliers_list), ], select =-c(population))

library("ggdendro")
distance <- dist(countries_scaled_no_outliers)
countries_cluster <- hclust(distance)

library("ape")
colors = c("red", "blue", "green", "black", "orange", "purple", "cyan")
cut = cutree(countries_cluster, 7)
par(mar=c(1,3,1,1))
plot(as.phylo(countries_cluster), type = "fan", cex = 0.6, tip.color = colors[cut])

countries_with_clusters <- mutate(countries_no_outliers, cluster = cut)

# Plot some clusters representations
ggplot(countries_with_clusters, aes(x=human_development_index, y=median_age, color = factor(cluster))) + geom_point()

ggplot(countries_with_clusters, aes(x=population_density, y = hospital_beds_per_thousand, color = factor(cluster))) + geom_point()
```

## Scatter plot matrix

```{r scattermatrix, fig.cap="Scatter plot matrix"}
library(psych, warn.conflicts = FALSE)

pairs.panels(countries, pch = ".")
```

# Evolution within the same classes

```{r}

# Function to plot pca
get_lines <- function(cluster_number, table, pca) {
  countries_names <- row.names(countries_with_clusters[countries_with_clusters$cluster == cluster_number, ])
  months_data <- unique(table$date)
  indexes_1 <- which(table$iso_code %in% countries_names)
  names <- NULL
  x_axis <- NULL
  y_axis <- NULL
  months <- NULL
  for (month in months_data) {
    indexes_2 <- which(table$date == month)
    indexes <- intersect(indexes_1, indexes_2)
    countries_number <- length(indexes)
    month_vector <- rep(c(month),times=countries_number)
    pca_interesting <- pca
    pca_interesting$x <- pca$x[indexes, ]
    x_axis <- c(x_axis, pca_interesting$x[, 1])
    y_axis <- c(y_axis, pca_interesting$x[, 2])
    names <- c(names, table[indexes, ]$iso_code)
    months <- c(months, month_vector)
  }
  df <- do.call(data.frame, list(x_axis, y_axis, names, as.Date(c(months), "%Y-%m-%d")))
  colnames(df) <- c("x", "y", "iso_code", "date")
  return(df)
}

#  Display plot for accumulative value for each countries cluster
number_of_clusters <- unique(countries_with_clusters$cluster)
for (i in number_of_clusters) {
  # df <- get_lines(i, time_series_monthly, pca)
    df <- get_lines(i, time_series_monthly_only_new_values, pca_new)

  plot <- ggplot() +
    geom_point(data = df, aes(x = x, y = y, colour = iso_code)) +
    labs(colour = "Country", x = "New deaths & cases", y = "vaccination & testing", title = "Evolution of coronavirus within the class")
  print(plot)
}

#  Display plot for new value for each countries cluster
number_of_clusters <- unique(countries_with_clusters$cluster)
for (i in number_of_clusters) {
  df <- get_lines(i, time_series_monthly_only_new_values, pca_new)
  plot <- ggplot() +
    # geom_line(data = df, aes(x = x, y = y, colour = iso_code)) +
    geom_point(data = df, aes(x = x, y = y, colour = date)) +
    labs(colour = "Date", x = "New deaths & cases", y = "vaccination & testing", title = "Evolution of coronavirus within the class")
  print(plot)
}


#  Display trajectory for each eu country + Chile
df <- get_lines(4, time_series_monthly_only_new_values, pca_new)
eu_countries_and_chl <- unique(df$iso_code)
for (country in eu_countries_and_chl) {
  country_data <- df[df$iso_code == country,]
  country_data[order(as.Date(country_data$date, format="%Y-%m-%d")),]
  plot <- ggplot() +
    # geom_line(data = df, aes(x = x, y = y, colour = iso_code)) +
    # geom_point(data = country_data, aes(x = x, y = y, colour = date)) +
    geom_path(data = country_data, aes(x = x, y = y, colour = date)) +
    labs(colour = "Date", x = "New deaths & cases", y = "vaccination & testing", title = country)
  print(plot)
}

```
```{r}
#  Display plot for new value for each countries cluster
number_of_clusters <- unique(countries_with_clusters$cluster)
for (i in number_of_clusters) {
  df <- get_lines(i, time_series_monthly_only_new_values, pca_new)
  plot <- ggplot() +
    geom_line(data = df, aes(x = date, y = y, colour = iso_code)) +
    # geom_line(data = df, aes(x = date, y = x, colour = iso_code)) +
    labs(colour = "Country", x = "Time", y = "Vaccination & testing", title = "Evolution of coronavirus within the class")
  print(plot)
}

number_of_clusters <- unique(countries_with_clusters$cluster)
for (i in number_of_clusters) {
  df <- get_lines(i, time_series_monthly_only_new_values, pca_new)
  plot <- ggplot() +
    geom_line(data = df, aes(x = date, y = x, colour = iso_code)) +
    # geom_line(data = df, aes(x = date, y = x, colour = iso_code)) +
    labs(colour = "Country", x = "Time", y = "Deaths and cases", title = "Evolution of coronavirus within the class")
  print(plot)
  }
```
```{r}
# Function to plot pca
table_no_boosters <- subset(time_series_monthly_only_new_values, select = -c(new_boosters))

get_lines <- function(cluster_number, table, pca) {
  countries_names <- row.names(countries_with_clusters[countries_with_clusters$cluster == cluster_number, ])
  months_data <- unique(table$date)
  indexes_1 <- which(table$iso_code %in% countries_names)
  names <- NULL
  x_axis <- NULL
  y_axis <- NULL
  months <- NULL
  for (month in months_data) {
    indexes_2 <- which(table$date == month)
    indexes <- intersect(indexes_1, indexes_2)
    countries_number <- length(indexes)
    month_vector <- rep(c(month),times=countries_number)
    pca_interesting <- pca
    pca_interesting$x <- pca$x[indexes, ]
    x_axis <- c(x_axis, pca_interesting$x[, 1])
    y_axis <- c(y_axis, pca_interesting$x[, 2])
    names <- c(names, table[indexes, ]$iso_code)
    months <- c(months, month_vector)
  }
  df <- do.call(data.frame, list(x_axis, y_axis, names, as.Date(c(months), "%Y-%m-%d")))
  colnames(df) <- c("x", "y", "iso_code", "date")
  return(df)
}

#  Display plot for accumulative value for each countries cluster
number_of_clusters <- unique(countries_with_clusters$cluster)
for (i in number_of_clusters) {
    df <- get_lines(i, table_no_boosters, pca_new_no_boosters)

  plot <- ggplot() +
    geom_point(data = df, aes(x = x, y = y, colour = iso_code)) +
    labs(colour = "Country", x = "New deaths & cases", y = "vaccination & testing", title = "Evolution of coronavirus within the class")
  print(plot)
}

#  Display plot for new value for each countries cluster
number_of_clusters <- unique(countries_with_clusters$cluster)
for (i in number_of_clusters) {
  df <- get_lines(i, table_no_boosters, pca_new_no_boosters)
  plot <- ggplot() +
    geom_point(data = df, aes(x = x, y = y, colour = date)) +
    labs(colour = "Date", x = "New deaths & cases", y = "vaccination & testing", title = "Evolution of coronavirus within the class")
  print(plot)
}


#  Display trajectory for each eu country + Chile
df <- get_lines(4, table_no_boosters, pca_new_no_boosters)
eu_countries_and_chl <- unique(df$iso_code)
for (country in eu_countries_and_chl) {
  country_data <- df[df$iso_code == country,]
  country_data[order(as.Date(country_data$date, format="%Y-%m-%d")),]
  plot <- ggplot() +
    geom_path(data = country_data, aes(x = x, y = y, colour = date)) +
    labs(colour = "Date", x = "New deaths & cases", y = "vaccination & testing", title = country) +
    lims(x = c(-8, 2), y = c(-9, 4))
  print(plot)
}
```

