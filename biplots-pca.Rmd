---
title: Analysis of COVID data through biplots.
author: "Alan Barahona-Ruiz, Natalia Markoborodova"
output:
    bookdown::pdf_document2
classoption: fleqn
fig_align: "center"
---

# Introduction

The main purpose of this project is to learn and apply the basics of data processing, visualization and analysis. We aim to get to know about Principal component analysis and how to represent data with it using biplots. 

The above named academic purpose will be achieved by working with real data set. The current pandemic situation gave us the inspiration to work with the data concerning the COVID-19. The idea of the project is to explore if certain socio-economical characteristics of a country influence its virus spread rate and consequences.

# Pre-proccesing

```{r echo=FALSE}
knitr::opts_chunk$set(echo = FALSE, dpi = 300)

library(dplyr, warn.conflicts = FALSE)
library(pander, warn.conflicts = FALSE)
library(knitr, warn.conflicts = FALSE)
library(ggplot2, warn.conflicts = FALSE)
library(reshape2, warn.conflicts = FALSE)
library(ggdendro, warn.conflicts = FALSE)
library(ape, warn.conflicts = FALSE)
library(psych, warn.conflicts = FALSE)
```

```{r loadingData}
set.seed(842744)
link <- "https://raw.githubusercontent.com/abarahonar/biplots-pca/master/owid-covid-data.csv"
data_original <- read.csv(url(link), header = TRUE)
```

The data used for this work comes from [Our World In Data's repositories](https://github.com/owid/covid-19-data/tree/master/public/data) (referenced as OWID for the remainder of this document). The last entry on the data set corresponds to 10/08/2021.

```{r deletingOWIDEntries}
# Remove aggregations of data
# Those are denoted as an iso_code starting with OWID
ptn <- "^[^O][^W][^I][^D]*" # Will match anything that doesn't start with OWID
ndx <- grep(ptn, data_original$iso_code, perl = TRUE)
data <- data_original[ndx, ]
```

The original data set contains `r count(data_original)` entries with `r ncol(data_original)` variables. However, not all the data is needed. There are several entries that are not useful as they correspond to aggregations of data in terms of geolocalization. These entries marked as OWID consists of `r ceiling((1 - count(data)/count(data_original))*100)`% of the original data set.

The variables in the data set can be used to represent two types of information: the evolution of the pandemic as a time series and metrics regarding the situation of the countries as a whole. The former correspond to dynamic data while the latter is static data. The reason for this distinction is because the static data is repeated through out every entry of each country. This amounts to a considerable amount of data repeated in the original data frame. By collecting this repeated data into a new a data frame and deleting it from the original one, we create two distinct data frames with a higher cohesion in regard of the variables they have.

## Countries data set
The variables used to represent the countries are as follows:

```{r definitionOfCountryVariables}
country_variables <- c(
  "population",
  "population_density",
  "median_age",
  "gdp_per_capita",
  "cardiovasc_death_rate",
  "diabetes_prevalence",
  "hospital_beds_per_thousand",
  "life_expectancy",
  "human_development_index",
  "female_smokers",
  "male_smokers",
  "extreme_poverty"
)

countries <- data[, which(names(data) %in% c("iso_code", country_variables))]
countries <- distinct(countries)
pander(country_variables)
```

The corresponding data frame regarding the countries contains `r count(countries)` entries. This amounts to the complete list of countries that OWID has data on. However, not every country on the data frame is useful in terms of analysis. This is due to the following reasons.

```{r reportingDates}
reporting_dates <- data[!duplicated(data$iso_code), ][c("iso_code", "date")]
rownames(reporting_dates) <- NULL

head_dates <- head(reporting_dates, n = 5)
tail_dates <- tail(reporting_dates, n = 5)

reporting_dates_t <- rbind(head_dates, tail_dates)
colnames(reporting_dates_t) <- c("ISO code", "Starting reporting date")

kable(reporting_dates_t, caption = "First and last 5 countries and their starting reporting dates. Alphabeticaly sorted. It can be seen in the fifth entry that the reporting date starts 1 year later in comparison to the majority of countries.") # nolint

fast_countries <- reporting_dates[reporting_dates$date < "2020-05-01", ]
countries <- countries[countries$iso_code %in% fast_countries$iso_code, ]
```

### Starting reporting date
The date on which every country started giving officials reports regarding the situation within the country varies greatly. To put this into perspective, in the Table \@ref(tab:reportingDates) offers a sample of the data frame. In it we can see that some countries started reporting relatively early (just two months after the perceived start of the pandemic), meanwhile others started after a year had already passed. This incongruity leaves several countries with less entries in the data frame, possibly creating some bias in the analysis. Due to this, some trimming based on the starting reporting date is done, considering the date 05/01/2020 as threshold. Countries that starting reporting after the threshold are deleted. The remaining countries consists of `r count(countries)` entries.

```{r deletingNAs}
countries$extreme_poverty[is.na(countries$extreme_poverty)] <- 0
countries <- na.omit(countries)
countries_with_names <- countries[, -1]
rownames(countries_with_names) <- countries[, 1]
countries <- countries_with_names
```

### Information missing
Several countries have one or more variables where they have NA (***not assigned***) values. Taking into consideration that certain techniques like clustering do not perform correctly in the presence of NAs. Due to this, countries that have one or more variable with NAs are removed, with one exception. The variable related to the percentage of the population living in extreme poverty is not assigned is not present in several first world countries. Due to this, if this variable is considered in the trimming for missing information several high profile countries would be lost. Is because of this that in the cases where the extreme poverty is missing, is assumed to be 0. After this the data frame consists of `r count(countries)` entries.


After these two trimming processes, the pre process of the country data frame is done. To see the behavior of the variables that compose the countries data frame, refer to the Figures \@ref(fig:lotBoxplots) and \@ref(fig:scatterMatrix).

```{r lotBoxplots, fig.cap="Boxplots of the different variables"}
# The scales are way too big, we should normalize
countries_scaled <- scale(subset(countries, select = -c(population)))
ggplot(melt(countries_scaled), aes(Var2, value)) +
  geom_boxplot() +
  labs(x = "Variable's name", y = "Standardized values") +
  coord_flip()
```

```{r scatterMatrix, fig.cap="Scatter plot matrix of the variables that constitute the country data set"}
pairs.panels(countries, pch = ".")
```

## Time series data set

```{r definitionOfTimeSeriesVariables}
columns_to_delete <- c(
  "continent",
  "location",
  "excess_mortality_cumulative_absolute",
  "excess_mortality_cumulative",
  "excess_mortality",
  "excess_mortality_cumulative_per_million",
  "handwashing_facilities",
  "icu_patients",
  "icu_patients_per_million",
  "hosp_patients",
  "hosp_patients_per_million",
  "weekly_icu_admissions",
  "weekly_icu_admissions_per_million",
  "weekly_hosp_admissions",
  "weekly_hosp_admissions_per_million",
  "new_cases_smoothed",
  "new_deaths_smoothed",
  "new_cases_smoothed_per_million",
  "new_deaths_smoothed_per_million",
  "new_tests_smoothed",
  "new_tests_smoothed_per_thousand",
  "new_vaccinations_smoothed",
  "new_vaccinations_smoothed_per_million",
  "positive_rate",
  "total_cases",
  "new_cases",
  "total_deaths",
  "new_deaths",
  "new_tests",
  "total_tests",
  "total_vaccinations",
  "people_vaccinated",
  "people_fully_vaccinated",
  "total_boosters",
  "new_vaccinations",
  "aged_65_older",
  "tests_units",
  "aged_70_older",
  "people_vaccinated_per_hundred",
  "people_fully_vaccinated_per_hundred"
)

unnecesary_variables <- c(
  columns_to_delete,
  country_variables
)

time_series <- data[, -which(names(data) %in% unnecesary_variables)]
time_series <- time_series[time_series$iso_code %in% rownames(countries), ]
time_series <- time_series[time_series$date >= "2020-05-01", ]
```

Regarding the time series, the data frame is composed of the following variables:

```{r timeSeriesDefinition}
pander(colnames(time_series))
```

In the same sense as with the countries data frame. The steps done are as follows:

### Deleting entries of removed countries

Due to the removal of several countries mentioned in previous chapters, the entries related to these countries must be deleted. This is done to be able to have to have both data frames refer to the same information. This means that both data frames must deal with the same countries.

### NAs
In the same sense as with the countries data frame, the presence of NAs can yield bad results depending on the technique used, this values have to be dealt with. However, it is not as simple as just deleting the variables that have some NA value, because, in essence, every variable has NAs. This is because when a country started reporting the COVID cases, the vaccine was no yet made. So there are no reports of people vaccinated during the early stages of the pandemic. The same applies to testing and almost every variable. Another problem that arises from the starting reporting date is that, every country started reporting after China. That means that every country has NAs but China on every variable.

To deal with both these problems, the fact that every remaining country started reporting before the 05/01/2020, every entry before that date can be deleted. After these, studying the percentage of NAs in every variable in the time series data frame gives us a list of variables that can be cut off. The threshold for this is 60% or more of NAs are not accepted. A rundown of these variables can be seen on the Table \@ref(tab:percentagesTable). However, not every entry is deleted. This is due to the in time mentioned before. So the variables related to testing and vaccination are not deleted. This is because this variables have valuable information, were introduced late, and can their value can be inferred.


```{r percentagesTable}
percentages <- sapply(data,
                      function(x) ceiling(sum(is.na(x)) / count(data) * 100))
percentages <- as.data.frame(percentages)
percentages <- t(percentages)
percentages <- percentages[percentages > 60, ]
percentages <- as.data.frame(percentages)
percentages <- cbind(Row.Names = rownames(percentages), percentages)
rownames(percentages) <- NULL
colnames(percentages) <- c("variable", "percentage")
percentages$variable <- substr(percentages$variable,
                              1,
                              nchar(percentages$variable) - 2)
kable(percentages, caption="Variables with a percentage of NA values over 60\\%") # nolint
```

Considering that several countries release a new report not a daily basis, the information in between is going to be NA. Because of this, a way to fill the gaps in between reports is to maintain the previous value until a new one is found. In the cases were no previous value exists, then is assumed to be 0.

### Cumulative data {#cumulativeData}

Due to the fact that the data frame has such a fine granularity (one entry per day per country) and several countries do not release reports daily, there are several entries that are repeated for shorts period of time. This happens per variable and is independent from the other variables. This means that some variables may repeat n times at time $t_0$, but another variable repeat m times at time $t_1$. Due to this and with the aim of reducing the granularity of the data frame, very variable is transformed to a cumulative form. This means that, if variable $y$ equals $x_0$ at time $t_0$ and variable $y$ equals $x_1$ at time $t_1$, then in a cumulative form $y$ equals $x_0$ at time $t_0$ and variable $y$ equals $x_0 + x_1$ at time $t_1$. This accumulation of data is done on a variable and country basis. 

```{r fillNAsWithCumulativeData}
# Actually the next elimination can be only applied to total cases because they are the sum of every day cases. If we set previous values for an NA in columns like new_cases then we artificially increase total cases(?) because to determine total we sum up new once # nolint
totals <- subset(time_series, select = -c(
  new_tests_per_thousand,
  new_deaths_per_million,
  tests_per_case,
  new_cases_per_million
))

totals_modifies <- totals[0, ]

for (i in rownames(countries)) { # for each country
  country_subset <- totals[totals$iso_code == i, ]
  country_subset_mod <- country_subset
  # for each column name
  for (j in colnames(subset(country_subset, select = -c(date, iso_code)))) {
    col.values <- country_subset[[j]] #select one column
    for (k in seq_along(col.values)) {
      if (is.na(col.values[[k]])) { # if value = NA
        if (k == 1) { # if first element -> set = 0
          country_subset_mod[[j]][[k]] <- 0.0
        } else { # else set the last known one
          country_subset_mod[[j]][[k]] <- country_subset_mod[[j]][[k - 1]]
        }
      }
    }
  }
  totals_modifies <- rbind(totals_modifies, country_subset_mod)
}

time_series <- totals_modifies
```

With the data frame in this form, the granularity can be easily obtained. This is done by selecting the entries in the data frame that are a month and week apart. With this we can create a data frame that contains information on a month granularity and another one with a week granularity. During the remainder of this document, the data frame with a month granularity is used.

```{r reductionOfRowsThroughAggregation}
aggregate_data <- function(countries, time_series, jump) {
  to_return <- time_series[0, ]
  for (i in rownames(countries)) {
    country_subset <- time_series[time_series$iso_code == i, ] # nolint
    j <- jump
    while (j <= nrow(country_subset)) {
      temp <- time_series[0, ]
      temp[1, ] <- NA
      temp[[1]][[1]] <- country_subset[[1]][[1]]
      temp[[2]][[1]] <- country_subset[[2]][[j]]
      for (k in colnames(subset(country_subset, select = -c(date, iso_code)))) {
        temp[[k]][[1]] <- country_subset[[k]][[j]]
      }
      to_return <- rbind(to_return, temp)
      j <- j + jump
    }
  }
  return(to_return)
}

time_series_weekly <- aggregate_data(countries, time_series, 7)
time_series_biweekly <- aggregate_data(countries, time_series, 14)
time_series_monthly <- aggregate_data(countries, time_series, 31)
```

However, a downside of having only cumulative data is that there is an intrinsic correlation in the variables. This is because they constantly grow. Due to this, a data frame consisting only the difference between one month and another is created. During the remainder of this document. The data frame with cumulative data will be referenced as total data meanwhile the one consisting of the difference as delta data

```{r timeSeriesWithDeltasFromCummulativeData}
new_t <- time_series_monthly[0, ]
for (i in rownames(countries)) {
  subset_t <- time_series_monthly[time_series_monthly$iso == i,]
  mod <- subset_t
  for (j in colnames(subset(subset_t, select = -c(date, iso_code, reproduction_rate, stringency_index)))) {
    col_values <- subset_t[[j]]
    number_of_entries_for_country = max(seq_along(col_values))
    while (number_of_entries_for_country > 1) {
      mod[[j]][[number_of_entries_for_country]] <- mod[[j]][[number_of_entries_for_country]] - mod[[j]][[number_of_entries_for_country - 1]]
      number_of_entries_for_country <- number_of_entries_for_country - 1
    }
  }
  new_t <- rbind(new_t, mod)
}


time_series_monthly_only_new_values <- new_t %>% 
  rename(
    new_cases = total_cases_per_million,
    new_deaths = total_deaths_per_million,
    new_tests = total_tests_per_thousand,
    new_vaccinations = total_vaccinations_per_hundred,
    new_boosters = total_boosters_per_hundred
    )
```

### Behaviour of the data frame

To see the behavior of the time series data frame, refer to the Section \@ref(behaviourTimeSeries). Some countries are hand picked to show the behavior of some variables. These countries corresponds to Russia, Chile, China, the United Stated of America, Germany, France, Brazil, Turkey, Italy and South Korea.

# Biplots creation

```{r pcaCreation, fig.cap="Variance of each components in the total data", fig.height=3, fig.width=3}
time_series_monthly_pca <- data.frame(time_series_monthly)
time_series_monthly_pca$iso_code <-  NULL
time_series_monthly_pca$date <- NULL
pca <- prcomp(time_series_monthly_pca, scale = TRUE)
pca_s <- summary(pca)

var_explained_df <- data.frame(PC= paste0("PC",1:7),
                               var_explained=(pca$sdev)^2/sum((pca$sdev)^2))

var_explained_df %>%
  ggplot(aes(x=PC,y=var_explained, group=1))+
  geom_point(size=4)+
  geom_line()+
  labs(x = "Dimension", y = "Variance explained")
```

```{r pcaNewCreation, fig.cap="Variance of each components in the delta data", fig.height=3, fig.width=3}

time_series_monthly_only_new_values_pca <- data.frame(time_series_monthly_only_new_values)
time_series_monthly_only_new_values_pca$iso_code <-  NULL
time_series_monthly_only_new_values_pca$date <- NULL
pca_new <- prcomp(time_series_monthly_only_new_values_pca, scale = TRUE)
pca_new_s <- summary(pca_new)

var_explained_df <- data.frame(PC= paste0("PC",1:7),
                               var_explained=(pca_new$sdev)^2/sum((pca_new$sdev)^2))

var_explained_df %>%
  ggplot(aes(x=PC,y=var_explained, group=1))+
  geom_point(size=4)+
  geom_line()+
  labs(x = "Dimension", y = "Variance explained")
```

PCA analysis is done on both the total and delta data frame. The variance concentrated in each component of the total and delta data can be seen in the Figures \@ref(fig:pcaCreation) and \@ref(fig:pcaNewCreation) respectively. In the figures it can be seen that with the total data, a bigger variance can be acomplished with the first two dimensions. To get the amount of information contained within the first two components, refer to the Figures \@ref(fig:pcaMainBiplot) and \@ref(fig:pcaNewMainBiplot). On both figures the corresponding biplot is included.

In the figure regarding the total data, a high correlation can be seen in the variables related to vaccinations, testing, cases and deaths, and to a certain degree, boosters.  This goes along what was said in the Section \@ref(cumulativeData): having data that grow continuously are bound to be somewhat correlated. This is not the case with the delta data. In the figure we can see some new relations regarding the data. Cases are related to deaths and vaccination to testing. It is important to note that because of this correlation, the information contained in the first two components of the total data is considerably more than of the total data (54% vs 45%).

Due to the strong presence of the variables related to vaccinations, testing, cases and deaths on the first component of the total data, we suggest that the first component correspond to the tangible effect of the COVID Meanwhile, on the second component the intangible effect of the COVID can be seen: both the reproduction rate of the COVID and the governments response. As for the delta data, the first components corresponds to the impact of the COVID (cases and death), and the second corresponds to the mitigation efforts done by the governments (vaccination, testing and boosters).

The importance of the components 3 and 4 (and the biplot projection) of both the total and delta data can be seen in the Section \@ref(restBiplots).

```{r biplotFunction}
get_pca_aces <- function(pca, y_dimention, left_limit, right_limit, bottom_limit, up_limmit, title = "") {

s <- summary(pca)
l_x <- pca$rotation[, 1] * 10
l_y <- pca$rotation[, y_dimention] * 10
lo <- which(l_y < 0)
hi <- which(l_y > 0)
l_pos <- l_y
l_pos <- replace(l_pos, lo, "1")
l_pos <- replace(l_pos, hi, "3")

plot(
  pca$x[, 1],
  pca$x[, y_dimention],
  xlab = paste("PCA 1 (", round(s$importance[2] * 100, 1), "%)", sep = ""),
  ylab = paste("PCA ", y_dimention, " (", round(s$importance[2+3*(y_dimention-1)] * 100, 1), "%)", sep = ""),
  las = 1,
  col = "white",
  main = title,
  ylim = c(bottom_limit, up_limmit),
  xlim = c(left_limit, right_limit)
  )
abline(v = 0, lty = 2, col = "grey50")
abline(h = 0, lty = 2, col = "grey50")
arrows(
  x0 = 0,
  x1 = l_x,
  y0 = 0,
  y1 = l_y,
  col =
  "red",
  length = 0.15,
  lwd = 1.5
  )
text(
  l_x,
  l_y,
  labels = row.names(pca$rotation),
  col = "red",
  pos = l_pos,
  lwd = 1.5,
  cex = 0.7
  )
}
```

```{r pcaMainBiplot, fig.cap="Biplot projection over the first two component in total data"}
get_pca_aces(pca, 2, -1, 6.5, -10, 9)
```

```{r pcaNewMainBiplot, fig.cap="Biplot projection over the first two component in the delta data"}
get_pca_aces(pca_new, 2, -1, 6.5, -10, 9)
```

To see the behavior of the total and delta data on the PCA domain, refer to the Figures \@ref(fig:countriesPCABiplot) and \@ref(fig:countriesPCANewBiplot) respectively. In the figures there are present every country in every month available on the data sets. 

```{r countriesPCABiplot, fig.cap="Behaviour of the total data in the first two components"}
s <- pca_s
l_x <- pca$rotation[, 1] * 5
l_y <- pca$rotation[, 2] * 5

plot(
  pca$x[, 1],
  pca$x[, 2],
  xlab = paste("PCA 1 (", round(s$importance[2] * 100, 1), "%)", sep = ""),
  ylab = paste("PCA 2 (", round(s$importance[5] * 100, 1), "%)", sep = ""),
  las = 1,
  cex = 0.5,
  col = "black",
  )
abline(v = 0, lty = 2, col = "grey50")
abline(h = 0, lty = 2, col = "grey50")
arrows(
  x0 = 0,
  x1 = l_x,
  y0 = 0,
  y1 = l_y,
  col = "#ff7f7f",
  length = 0.15,
  lwd = 1.5,
  cex = 0.5
  )
```

```{r countriesPCANewBiplot, fig.cap="Behaviour of the delta data in the first two components"}
s <- pca_new_s
l_x <- pca_new$rotation[, 1] * 8
l_y <- pca_new$rotation[, 2] * 8

plot(
  pca_new$x[, 1],
  pca_new$x[, 2],
  xlab = paste("PCA 1 (", round(s$importance[2] * 100, 1), "%)", sep = ""),
  ylab = paste("PCA 2 (", round(s$importance[5] * 100, 1), "%)", sep = ""),
  las = 1,
  cex = 0.5,
  col = "black",
  )
abline(v = 0, lty = 2, col = "grey50")
abline(h = 0, lty = 2, col = "grey50")
arrows(
  x0 = 0,
  x1 = l_x,
  y0 = 0,
  y1 = l_y,
  col = "#ff7f7f",
  length = 0.15,
  lwd = 1.5,
  cex = 0.5
  )
```

```{r pcaWithoutBoosters}
 # PCA without boosters
pca_no_boosters <- prcomp(subset(time_series_monthly_pca, select = -c(total_boosters_per_hundred)), scale = TRUE)
pca_new_no_boosters <- prcomp(subset(time_series_monthly_only_new_values_pca, select = -c(new_boosters)), scale = TRUE)
```

After analyzing both figures, it can be seen that the importance of the boosters in comparison to the rest of the variables. Due to this plus the low presence on the original data set and in an effort to reduce the number of variables, we decided to delete the variable associated to the booster. After the removal of the booster variable, the resulting plots can be seen in Figures \@ref(fig:pcaMainBiplotNoBooster) and \@ref(fig:pcaNewMainBiplotNoBooster). Due to the low presence of the variable, the impact is not that noticeable, mainly an improvement on the importance of the components remaining components. However, that was to be expected due to having one variable less.

```{r pcaMainBiplotNoBooster, fig.cap="Biplot projection over the first two component in the total data without boosters"}
get_pca_aces(pca_no_boosters, 2, -1, 6.5, -10, 9)
```

```{r pcaNewMainBiplotNoBooster,  fig.cap="Biplot projection over the first two component in the delta data without boosters"}
get_pca_aces(pca_new_no_boosters, 2, -6.5, 1, -10, 9)
```

For the remainder of this document, the data set that is used correspond to the delta data with no booster, which is going to be referred from this point onwards as data.

```{r interestingCountries}
# interesting_countries <- c("RUS", "CHL", "CHN", "USA", "DEU", "FRA", "BRA", "TUR", "ITA", "KOR")
# 
# get_lines <- function() {
#   months_data <- unique(time_series_monthly$date)
#   indexes_1 <- which(time_series_monthly$iso_code %in% interesting_countries)
#   names <- NULL
#   x_axis <- NULL
#   y_axis <- NULL
#   for (month in months_data) {
#     indexes_2 <- which(time_series_monthly$date == month)
#     indexes <- intersect(indexes_1, indexes_2)
#     pca_interesting <- pca
#     pca_interesting$x <- pca$x[indexes, ]
#     x_axis <- c(x_axis, pca_interesting$x[, 1])
#     y_axis <- c(y_axis, pca_interesting$x[, 2])
#     names <- c(names, time_series_monthly[indexes, ]$iso_code)
#   }
#   df <- do.call(data.frame, list(x_axis, y_axis, names))
#   colnames(df) <- c("x", "y", "iso_code")
#   return(df)
# }
# 
# cols <- rainbow(length(interesting_countries))
# l_x <- pca$rotation[, 1] * 5
# l_y <- pca$rotation[, 2] * 5
# df <- get_lines()
# 
# ggplot() +
#   geom_line(data = df, aes(x = x, y = y, colour = iso_code)) +
#   labs(colour = "Country", x = "Deaths, vaccinations and testing", y = "Reproduction and stringency", title = "Evolution of coronavirus")
```

# Hierarchical clustering

For clustering the countries, we're not taking into consideration absolute values like population. Instead, to compare the countries we take into consideration relative parameters like density of population. Also, we excluded certain countries from our data frame: Bangladesh, Malta, Mauritius and Singapore. These countries have way too high population density which would group them in a separate class. After clustering the data and analyzing the dendogram we decided to divide our data set into 7 classes. This can be seen in the Figure \@ref(fig:dendogram).

```{r dendogram, fig.cap="Hierarchical clustering"}
# Remove outliers
outliers_list <- c("MUS", "MLT", "BGD", "SGP")
countries_scaled_no_outliers <- countries_scaled[!(row.names(countries_scaled) %in% outliers_list), ]
# No outliers + no absolute population
countries_no_outliers <-subset(countries[!(row.names(countries) %in% outliers_list), ], select =-c(population))

distance <- dist(countries_scaled_no_outliers)
countries_cluster <- hclust(distance)

colors = c("red", "blue", "green", "black", "orange", "purple", "cyan")
cut = cutree(countries_cluster, 7)
par(mar=c(1,3,1,1))
plot(as.phylo(countries_cluster), type = "fan", cex = 0.6, tip.color = colors[cut])

countries_with_clusters <- mutate(countries_no_outliers, cluster = cut)
```

To see the behaviour of the clusters on certain of the variables, refer to the Figures \@ref(fig:clusterHumanMedian) and \@ref(fig:clusterDensityHospitalBeds).

```{r clusterHumanMedian, fig.cap="Distribution of the classes given the human development index and median age", fig.height=3}
ggplot(countries_with_clusters, aes(x=human_development_index, y=median_age, color = factor(cluster))) +
  geom_point() +
  labs(x = "Human development index", y = "Median age")
```

```{r clusterDensityHospitalBeds, fig.cap="Distribution of the classes given population density and hospital beds per thousand", fig.height=3}
ggplot(countries_with_clusters, aes(x=population_density, y = hospital_beds_per_thousand, color = factor(cluster))) +
  geom_point() +
  labs(x = "Population density", y = "Hospital beds per thousand")
```

# Evolution within the same classes

On the next stage of the project, we aimed to have a closer look at the behavior of the data within clusters. For that, we first plotted all the data for each cluster on the same plane. Taking into consideration the visualisation results of the PCA analysis (Figure 10), the axes can be interpreted as following: the values that are the most significant for defining the value of the first PCA component are new deaths and new cases, so we interpret the X axis as the composition of them. The Y axis is most influenced by the new_tests and new_vaccinations parameters, therefore Y represents a composition of these two. 
As it can be read from the Figure 10, the values of both PCA components and two above named data compositions are inversely proportional, which means that with the increment of X value the number of new deaths and new cases decreases, and the increment of Y means recession of new_tests and new_vaccinations.

```{r pcaFunctionDefinition}
# Function to plot pca
get_lines <- function(cluster_number, table, pca) {
  countries_names <- row.names(countries_with_clusters[countries_with_clusters$cluster == cluster_number, ])
  months_data <- unique(table$date)
  indexes_1 <- which(table$iso_code %in% countries_names)
  names <- NULL
  x_axis <- NULL
  y_axis <- NULL
  z_axis <- NULL
  months <- NULL
  clusters <- NULL
  for (month in months_data) {
    indexes_2 <- which(table$date == month)
    indexes <- intersect(indexes_1, indexes_2)
    countries_number <- length(indexes)
    month_vector <- rep(c(month),times=countries_number)
    cluster_vector <- rep(c(cluster_number), times=countries_number)
    pca_interesting <- pca
    pca_interesting$x <- pca$x[indexes, ]
    x_axis <- c(x_axis, pca_interesting$x[, 1])
    y_axis <- c(y_axis, pca_interesting$x[, 2])
    z_axis <- c(z_axis, pca_interesting$x[, 3])
    names <- c(names, table[indexes, ]$iso_code)
    months <- c(months, month_vector)
    clusters <- c(clusters, cluster_vector)
  }
  df <- do.call(data.frame, list(x_axis, y_axis, z_axis, names, as.Date(c(months), "%Y-%m-%d"), clusters))
  colnames(df) <- c("x", "y", "z", "iso_code", "date", "cluster")
  return(df)
}

table_no_boosters <- subset(time_series_monthly_only_new_values, select = -c(new_boosters))
```

```{r latinAmericaDistribution, fig.height=3, fig.cap="Distribution of latin american countries"}
df <- get_lines(2, table_no_boosters, pca_new_no_boosters)
plot <- ggplot() +
  geom_point(data = df, aes(x = x, y = y, colour = iso_code)) +
  labs(colour = "Country", x = "New deaths & cases", y = "vaccination & testing")
print(plot)
```

```{r europeDistribution, fig.height=3, fig.cap="Distribution of european countries"}
df <- get_lines(4, table_no_boosters, pca_new_no_boosters)
plot <- ggplot() +
  geom_point(data = df, aes(x = x, y = y, colour = iso_code)) +
  labs(colour = "Country", x = "New deaths & cases", y = "vaccination & testing")
print(plot)
```

Analyzing  the data within each single cluster we did not really notice any specific behavior for each country. Therefore we decided to take the total data for each cluster and compare it with one another. In the (Figure \@ref(fig:biplotDeltaValuesNoTimeClassesAllData)) we can notice that for each class the data is indeed accumulated in an area of the graph which means there can be some kind of correlation to explore.

More than that, though we could not extract a specific behavior for a country, we can still notice a common shape formed by the data points for each cluster: each graph tends to display a line which goes from the top left to the bottom right. That gave us a hint to have a look at how the data behaves on the time line.

```{r biplotDeltaValuesNoTimeClassesAllData, fig.height=3, fig.cap="Distribution of the classes over the biplot"}
number_of_clusters <- unique(countries_with_clusters$cluster)
final_df <- data.frame()
for (i in number_of_clusters) {
    df <- get_lines(i, table_no_boosters, pca_new_no_boosters)
    final_df <- rbind(final_df, df)
  }
p <- ggplot() + 
  geom_point(data=final_df, aes(x = x, y = y, colour = cluster)) +
  labs(colour = "Country", x = "New deaths & cases", y = "vaccination & testing")
print(p)
```

The following graphs give us another dimension to analyze: the color of points represent timeline, from the earliest dates (darker blue) to the latest (light blue). Here we can clearly see a movement with time to the down on Y axis within each cluster. 
On the example of the forth cluster we can also extract the following behavioral pattern: the earlier data entries are concentrated in the right top corner and with the time at first we see the movement to the left upper direction, which means that the new number of tests and vaccinations decreases and the number of new cases and deaths increases. Later in the timeline, the countries of the cluster increase vaccination and testing and new cases and deaths rate decrease.

From this data behavior we can conclude that new death rate and cases are inversely proportional to the vaccination and testing rate. Taking that into consideration, we can suppose that vaccination helps to decrease the spread of the virus.

This information can also be interpreted in another way. As we mentioned before in the PCA analysis, the Y axis represents the response measures of the governments. We can see that in the beginning of the pandemic the response was not immediate (the countries would not start mass testing and vaccination right away). With the time the tendency was that the governments would amplify their response measures. Some possible reasons might be that the world was not prepared for a pandemic of such a scale and did not know how to react or that we simply did not have enough resources to start a mass vaccination and testing campaign.

The data behavior described on the example of European countries cluster also applies to the other clusters. The corresponding praphs can be found in the Appendix section.

```{r latinAmericanTimeDistribution, fig.height=3, fig.cap="Time distribution of latin american countries"}
df <- get_lines(2, table_no_boosters, pca_new_no_boosters)
plot <- ggplot() +
  geom_point(data = df, aes(x = x, y = y, colour = date)) +
  labs(colour = "Date", x = "New deaths & cases", y = "vaccination & testing")
print(plot)
```

```{r europeanTimeDistribution, fig.height=3, fig.cap="Time distribution of european countries"}
df <- get_lines(4, table_no_boosters, pca_new_no_boosters)
plot <- ggplot() +
  geom_point(data = df, aes(x = x, y = y, colour = date)) +
  labs(colour = "Date", x = "New deaths & cases", y = "vaccination & testing")
print(plot)
```

The previous visualizations gave us an idea that there is a common data trajectory on the timeline for all the countries. Though we have not yet seen a clear data correlation withing each cluster. For a more detailed examination of any common patterns we decided to have a look at how PCA components behave on a timeline for each country withing a cluster.

From the following plots (\@ref(fig:latinAmericaPCA1) - \@ref(fig:europaPCA3)) we can see common behavior for the first, second and third PCA components within clusters. With that we can conclude that within the clusters that we derived from the static variables there is also a correlation of the time dependent attributes. That can possibly mean that there is a correlation between the socio-economical situation of a country and its politics on response to the pandemic.

```{r latinAmericaPCA1, fig.height=3, fig.cap="Evolution of the first component in Latin America"}
df <- get_lines(2, table_no_boosters, pca_new_no_boosters)
plot <- ggplot() +
  geom_line(data = df, aes(x = date, y = x, colour = iso_code)) +
  # geom_line(data = df, aes(x = date, y = x, colour = iso_code)) +
  labs(colour = "Country", x = "Time", y = "Deaths and cases")
print(plot)
```

```{r europePCA1, fig.height=3, fig.cap="Evolution of the first component in Europe"}
df <- get_lines(4, table_no_boosters, pca_new_no_boosters)
plot <- ggplot() +
  geom_line(data = df, aes(x = date, y = x, colour = iso_code)) +
  # geom_line(data = df, aes(x = date, y = x, colour = iso_code)) +
  labs(colour = "Country", x = "Time", y = "Deaths and cases")
print(plot)
```

```{r latinAmericaPCA2, fig.height=3, fig.cap="Evolution of the second component in Latin America"}
df <- get_lines(2, table_no_boosters, pca_new_no_boosters)
plot <- ggplot() +
  geom_line(data = df, aes(x = date, y = y, colour = iso_code)) +
  labs(colour = "Country", x = "Time", y = "Vaccination & testing")
print(plot)
```

```{r europaPCA2, fig.height=3, fig.cap="Evolution of the second component in Latin America"}
df <- get_lines(4, table_no_boosters, pca_new_no_boosters)
plot <- ggplot() +
  geom_line(data = df, aes(x = date, y = y, colour = iso_code)) +
  labs(colour = "Country", x = "Time", y = "Vaccination & testing")
print(plot)
```

```{r latinAmericaPCA3, fig.height=3, fig.cap="Evolution of the third component in Latin America"}
df <- get_lines(2, table_no_boosters, pca_new_no_boosters)
plot <- ggplot() +
  geom_line(data = df, aes(x = date, y = z, colour = iso_code)) +
  labs(colour = "Country", x = "Time", y = "PCA 3")
print(plot)
```

```{r europaPCA3, fig.height=3, fig.cap="Evolution of the third component in Latin America"}
df <- get_lines(4, table_no_boosters, pca_new_no_boosters)
plot <- ggplot() +
  geom_line(data = df, aes(x = date, y = z, colour = iso_code)) +
  labs(colour = "Country", x = "Time", y = "Reproduction rate & Stringency index")
print(plot)
```

Finally, in order to see if the conclusions that we made based on the combined data apply to a single countries we plotted the trajectory of first two PCA components behavior for each country in the European cluster. So, our previous guess on the common trajectory was confirmed. With the time, at first the countries do not apply strict response which causes deterioration of the situation, but increasing of vaccination and testing leads to a better cases and death rate. 

Although, not depending on the vaccination rate, sometimes we observe influx of new cases and death rate. We suppose that such a pattern corresponds to virus variants and/or a new wave.  

```{r FRA, fig.height=3, fig.cap="Evolution of COVID in France"}
# "FRA", "HUN", "DEU"
df <- get_lines(4, table_no_boosters, pca_new_no_boosters)
country_data <- df[df$iso_code == "FRA",]
plot <- ggplot() +
  geom_path(data = country_data, aes(x = x, y = y, colour = date)) +
  labs(colour = "Date", x = "New deaths & cases", y = "vaccination & testing") +
  lims(x = c(-8, 2), y = c(-9, 4))
print(plot)
```

```{r DEU, fig.height=3, fig.cap="Evolution of COVID in Germany"}
country_data <- df[df$iso_code == "DEU",]
plot <- ggplot() +
  geom_path(data = country_data, aes(x = x, y = y, colour = date)) +
  labs(colour = "Date", x = "New deaths & cases", y = "vaccination & testing") +
  lims(x = c(-8, 2), y = c(-9, 4))
print(plot)
```

```{r HUN, fig.height=3, fig.cap="Evolution of COVID in Hungary"}
country_data <- df[df$iso_code == "HUN",]
plot <- ggplot() +
  geom_path(data = country_data, aes(x = x, y = y, colour = date)) +
  labs(colour = "Date", x = "New deaths & cases", y = "vaccination & testing") +
  lims(x = c(-8, 2), y = c(-9, 4))
print(plot)
```

# Conclusion

To conclude this work, we can say that the goals set at the beginning of the project are fulfilled. We learned and applied the basics of data science, a topic that was not on our skill set, and gain and improve our knowledge of the R programming language. We managed to interpret the variables from the PCA components and apply them to data interpretation. This was done through the analysis of the correspondent biplots.

A significant part of the project was dedicated to data processing, which helped us to develop skills in this sphere for future endeavors in this industry. Furthermore, due to the amount of plots that we had to analyze, this project also helped us improving our analytic and interpretation abilities.

In conclusion, this project was a good introduction to data science.

\newpage

# Appendix

## Behaviour of the time series {#behaviourTimeSeries}
```{r somePlotsOfCountriesVariables, fig.height=3}
interesting_countires <- c(
  "RUS",
  "CHL",
  "CHN",
  "USA",
  "DEU",
  "FRA",
  "BRA",
  "TUR",
  "ITA",
  "KOR"
  ) #countries to plot

# Plot all totals
subset <- time_series[time_series$iso_code %in% interesting_countires, ]
p <- ggplot(data = subset,
            aes(x = date, y = total_cases_per_million,
            group = iso_code)) +
  geom_line(aes(color = iso_code)) +
  theme(axis.text.x = element_blank()) + 
  labs(x = "Date", y = "Total cases per million", title = "Evolution of cases")
print(p)
# }
subset <- time_series[time_series$iso_code %in% interesting_countires, ]
p <- ggplot(data = subset,
            aes(x = date, y = total_deaths_per_million, group = iso_code)) +
  geom_line(aes(color = iso_code)) +
  theme(axis.text.x = element_blank()) + 
  labs(x = "Date", y = "Total deaths per million", title = "Evolution of deaths")
print(p)

subset <- time_series[time_series$iso_code %in% interesting_countires, ]
p <- ggplot(data = subset,
            aes(x = date, y = reproduction_rate, group = iso_code)) +
  geom_line(aes(color = iso_code)) +
  theme(axis.text.x = element_blank()) + 
  labs(x = "Date", y = "Reproduction rate", title = "Evolution of reproduction rate")
print(p)

subset <- time_series[time_series$iso_code %in% interesting_countires, ]
p <- ggplot(data = subset,
            aes(x = date, y = total_tests_per_thousand, group = iso_code)) +
  geom_line(aes(color = iso_code)) +
  theme(axis.text.x = element_blank()) + 
  labs(x = "Date", y = "Total tests per thousand", title = "Evolution of testing")
print(p)

subset <- time_series[time_series$iso_code %in% interesting_countires, ]
p <- ggplot(data = subset,
            aes(x = date,
                y = total_vaccinations_per_hundred,
                group = iso_code)) +
  geom_line(aes(color = iso_code)) +
  theme(axis.text.x = element_blank()) + 
  labs(x = "Date", y = "Total vaccinations per hundred", title = "Evolution of vaccination")
print(p)

subset <- time_series[time_series$iso_code %in% interesting_countires, ]
p <- ggplot(data = subset,
            aes(x = date, y = total_boosters_per_hundred, group = iso_code)) +
  geom_line(aes(color = iso_code)) +
  theme(axis.text.x = element_blank()) + 
  labs(x = "Date", y = "Total boosters per hundred", title = "Evolution of boosters")
print(p)

subset <- time_series[time_series$iso_code %in% interesting_countires, ]
p <- ggplot(data = subset,
            aes(x = date, y = stringency_index, group = iso_code)) +
  geom_line(aes(color = iso_code)) +
  theme(axis.text.x = element_blank()) + 
  labs(x = "Date", y = "Stringency index", title = "Evolution of stringency index")
print(p)
```

## Components 3 and 4 of the PCA analysis {#restBiplots}
```{r pcaBiplots}
get_pca_aces(pca, 3, -1, 6.5, -10, 9, "1st and 3rd components of total data")
get_pca_aces(pca, 4, -1, 6.5, -10, 9, "1st and 4rd components of total data")
get_pca_aces(pca_new, 3, -1, 6.5, -10, 9, "1st and 3rd components of delta data")
get_pca_aces(pca_new, 4, -1, 6.5, -10, 9, "1st and 4rd components of delta data")
get_pca_aces(pca_no_boosters, 3, -1, 6.5, -10, 9, "1st and 3rd components of total data with no boosters")
get_pca_aces(pca_no_boosters, 4, -1, 6.5, -10, 9, "1st and 4rd components of total data with no boosters")
get_pca_aces(pca_new_no_boosters, 3, -6.5, 1, -10, 9, "1st and 3rd components of delta data with no boosters")
get_pca_aces(pca_new_no_boosters, 4, -6.5, 1, -10, 9, "1st and 4rd components of delta data with no boosters")
```

## Biplot of countries

### Biplot of data, grouped by countries

```{r biplotDeltaValuesWithoutTimeClasses, fig.height=3}
table_no_boosters <- subset(time_series_monthly_only_new_values, select = -c(new_boosters))

#  Display plot for accumulative value for each countries cluster
number_of_clusters <- unique(countries_with_clusters$cluster)
for (i in number_of_clusters) {
    df <- get_lines(i, table_no_boosters, pca_new_no_boosters)

  plot <- ggplot() +
    geom_point(data = df, aes(x = x, y = y, colour = iso_code)) +
    labs(colour = "Country", x = "New deaths & cases", y = "vaccination & testing", title = "Distribution of coronavirus")
  print(plot)
}
```

### Biplot of data, grouped by time

```{r biplotDeltaValuesWithTimeClasses, fig.height=3}
#  Display plot for new value for each countries cluster
number_of_clusters <- unique(countries_with_clusters$cluster)
for (i in number_of_clusters) {
  df <- get_lines(i, table_no_boosters, pca_new_no_boosters)
  plot <- ggplot() +
    geom_point(data = df, aes(x = x, y = y, colour = date)) +
    labs(colour = "Date", x = "New deaths & cases", y = "vaccination & testing", title = "Evolution of coronavirus")
  print(plot)
}
```

### Individual Trayectory of certain countries

```{r countriesBiplotIndividually, fig.height=3}
#  Display trajectory for each eu country + Chile
df <- get_lines(4, table_no_boosters, pca_new_no_boosters)
eu_countries_and_chl <- unique(df$iso_code)
for (country in eu_countries_and_chl) {
  country_data <- df[df$iso_code == country,]
  country_data[order(as.Date(country_data$date, format="%Y-%m-%d")),]
  plot <- ggplot() +
    geom_path(data = country_data, aes(x = x, y = y, colour = date)) +
    labs(colour = "Date", x = "New deaths & cases", y = "vaccination & testing", title = country) +
    lims(x = c(-8, 2), y = c(-9, 4))
  print(plot)
}
```
### Trayectory of the PCA component 1

```{r PCA1evolutionOverTimeDeltaValues, fig.height=3}
number_of_clusters <- unique(countries_with_clusters$cluster)
for (i in number_of_clusters) {
  df <- get_lines(i, table_no_boosters, pca_new_no_boosters)
  plot <- ggplot() +
    geom_line(data = df, aes(x = date, y = x, colour = iso_code)) +
    # geom_line(data = df, aes(x = date, y = x, colour = iso_code)) +
    labs(colour = "Country", x = "Time", y = "Deaths and cases", title = "Evolution of the PCA 1 within the class")
  print(plot)
  }
```

### Trayectory of the PCA component 2

```{r PCA2evolutionOverTimeDeltaValues}
#  Display plot for new value for each countries cluster
number_of_clusters <- unique(countries_with_clusters$cluster)
for (i in number_of_clusters) {
  df <- get_lines(i, table_no_boosters, pca_new_no_boosters)
  plot <- ggplot() +
    geom_line(data = df, aes(x = date, y = y, colour = iso_code)) +
    labs(colour = "Country", x = "Time", y = "Vaccination & testing", title = "Evolution of the PCA 2 within the class")
  print(plot)
}
```